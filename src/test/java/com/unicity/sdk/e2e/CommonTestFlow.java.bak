package com.unicity.sdk.e2e;

import com.unicity.sdk.ISerializable;
import com.unicity.sdk.StateTransitionClient;
import com.unicity.sdk.address.DirectAddress;
import com.unicity.sdk.api.Authenticator;
import com.unicity.sdk.api.RequestId;
import com.unicity.sdk.api.SubmitCommitmentResponse;
import com.unicity.sdk.api.SubmitCommitmentStatus;
import com.unicity.sdk.transaction.InclusionProofVerificationStatus;
import com.unicity.sdk.predicate.*;
import com.unicity.sdk.serializer.token.TokenJsonDeserializer;
import com.unicity.sdk.serializer.transaction.TransactionJsonDeserializer;
import com.unicity.sdk.shared.hash.DataHash;
import com.unicity.sdk.shared.hash.DataHasher;
import com.unicity.sdk.shared.hash.DataHasherFactory;
import com.unicity.sdk.shared.hash.HashAlgorithm;
import com.unicity.sdk.shared.hash.IDataHasher;
import com.unicity.sdk.shared.signing.SigningService;
import com.unicity.sdk.token.Token;
import com.unicity.sdk.token.TokenFactory;
import com.unicity.sdk.token.TokenId;
import com.unicity.sdk.token.TokenState;
import com.unicity.sdk.token.TokenType;
import com.unicity.sdk.token.fungible.CoinId;
import com.unicity.sdk.token.fungible.TokenCoinData;
import com.unicity.sdk.transaction.Commitment;
import com.unicity.sdk.transaction.MintTransactionData;
import com.unicity.sdk.transaction.Transaction;
import com.unicity.sdk.transaction.TransactionData;
import com.unicity.sdk.transaction.TokenSplitBuilder;
import com.unicity.sdk.utils.InclusionProofUtils;

import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Common test flows for token operations.
 */
public class CommonTestFlow {
    private static final SecureRandom random = new SecureRandom();
    private static final byte[] INITIAL_OWNER_SECRET = "Alice".getBytes(StandardCharsets.UTF_8);
    private static final byte[] BOB_SECRET = "Bob".getBytes(StandardCharsets.UTF_8);
    
    private static final IPredicateFactory predicateFactory = new PredicateFactory();
    private static final TokenFactory tokenFactory = new TokenFactory(predicateFactory);
    private static final TokenJsonDeserializer tokenDeserializer = new TokenJsonDeserializer();
    private static final TransactionJsonDeserializer transactionDeserializer = new TransactionJsonDeserializer();

    private static void performCheckForSplitTokens(
            List<Token<Transaction<MintTransactionData<?>>>> actualTokens,
            List<TokenCoinData> expectedCoinDataList) {
        
        assertEquals(expectedCoinDataList.size(), actualTokens.size());

        for (int i = 0; i < actualTokens.size(); i++) {
            Token<Transaction<MintTransactionData<?>>> actualToken = actualTokens.get(i);
            Map<CoinId, BigInteger> expectedCoins = expectedCoinDataList.get(i).getCoins();

            Map<CoinId, BigInteger> actualCoins = actualToken.getCoins().getCoins();
            assertNotNull(actualCoins, "actualToken at index " + i + " has no coins");

            assertEquals(expectedCoins, actualCoins);
        }
    }

    public static void testTransferFlow(StateTransitionClient client) throws Exception {
        // Alice
        byte[] coinId1 = new byte[32];
        byte[] coinId2 = new byte[32];
        random.nextBytes(coinId1);
        random.nextBytes(coinId2);
        
        Map<CoinId, BigInteger> coins = new HashMap<>();
        coins.put(new CoinId(coinId1), BigInteger.valueOf(10 + random.nextInt(90)));
        coins.put(new CoinId(coinId2), BigInteger.valueOf(10 + random.nextInt(90)));
        TokenCoinData coinData = TokenCoinData.create(coins);

        MintTokenUtils.MintData mintData = MintTokenUtils.createMintData(INITIAL_OWNER_SECRET, coinData).get();
        Token<Transaction<MintTransactionData<ISerializable>>> aliceToken = MintTokenUtils.mintToken(client, mintData).get();

        DirectAddress mintAddress = DirectAddress.create(mintData.predicate.getReference()).get();
        DirectAddress genesisAddress = DirectAddress.fromJSON(aliceToken.getGenesis().getData().getRecipient()).get();
        assertEquals(mintAddress, genesisAddress);

        // Recipient (Bob) prepares the info for the transfer: new state and address
        String bobTokenState = "Bob's custom data";
        byte[] bobNonce = new byte[32];
        random.nextBytes(bobNonce);
        SigningService bobSigningService = SigningService.createFromSecret(BOB_SECRET, bobNonce).get();
        MaskedPredicate bobPredicate = MaskedPredicate.create(
            aliceToken.getId(),
            aliceToken.getType(),
            bobSigningService,
            HashAlgorithm.SHA256,
            bobNonce
        ).get();
        DirectAddress bobAddress = DirectAddress.create(bobPredicate.getReference()).get();

        // Alice creates transfer transaction using Bob's address and new token state
        SigningService aliceSigningService = SigningService.createFromSecret(INITIAL_OWNER_SECRET, mintData.nonce).get();
        Transaction<TransactionData> transaction = MintTokenUtils.sendToken(
            client,
            aliceToken,
            aliceSigningService,
            bobAddress,
            bobTokenState
        ).get();

        // Bob imports token+transaction
        Token<?> importedToken = tokenFactory.create(aliceToken.toJson()).get();
        // Recipient gets transaction from sender
        Transaction<?> importedTransaction = transactionDeserializer.deserialize(
            importedToken.getId(),
            importedToken.getType(),
            TransactionJsonSerializer.serialize(transaction)
        ).get();

        // Finish the transaction with Bob's predicate
        TokenState bobTokenState_ = TokenState.create(bobPredicate, bobTokenState.getBytes(StandardCharsets.UTF_8)).get();
        Token<?> bobToken = client.finishTransaction(importedToken, bobTokenState_, importedTransaction).get();

        SigningService minterSigningService = SigningService.createFromSecret(
            INITIAL_OWNER_SECRET,
            aliceToken.getState().getUnlockPredicate().getNonce()
        ).get();
        
        assertTrue(bobToken.getState().getUnlockPredicate().isOwner(bobSigningService.getPublicKey()).get());
        Transaction<?> lastTx = bobToken.getTransactions().get(bobToken.getTransactions().size() - 1);
        assertTrue(((TransactionData)lastTx.getData()).getSourceState().getUnlockPredicate().isOwner(minterSigningService.getPublicKey()).get());
        assertEquals(aliceToken.getId(), bobToken.getId());
        assertEquals(aliceToken.getType(), bobToken.getType());
        assertEquals(aliceToken.getData(), bobToken.getData());
        assertEquals(aliceToken.getCoins().toJson(), bobToken.getCoins().toJson());

        // Verify the original minted token has been spent
        SigningService senderSigningService = SigningService.createFromSecret(INITIAL_OWNER_SECRET, mintData.nonce).get();
        InclusionProofVerificationStatus mintedTokenStatus = client.getTokenStatus(aliceToken, senderSigningService.getPublicKey()).get();
        assertEquals(InclusionProofVerificationStatus.OK, mintedTokenStatus);

        // Verify the updated token has not been spent
        InclusionProofVerificationStatus transferredTokenStatus = client.getTokenStatus(bobToken, bobSigningService.getPublicKey()).get();
        assertEquals(InclusionProofVerificationStatus.PATH_NOT_INCLUDED, transferredTokenStatus);

        // Transfer to the third owner (Carol) with UnmaskedPredicate
        byte[] carolSecret = "Carol".getBytes(StandardCharsets.UTF_8);
        byte[] carolNonce = new byte[32];
        random.nextBytes(carolNonce);
        SigningService carolSigningService = SigningService.createFromSecret(carolSecret, carolNonce).get();
        DataHash carolRef = UnmaskedPredicate.calculateReference(
            aliceToken.getType(), 
            carolSigningService.getAlgorithm(), 
            carolSigningService.getPublicKey(), 
            HashAlgorithm.SHA256
        ).get();
        DirectAddress carolAddress = DirectAddress.create(carolRef).get();

        // Create transfer transaction Bob -> Carol
        Transaction<TransactionData> txToCarol = MintTokenUtils.sendToken(
            client,
            (Token<Transaction<MintTransactionData<ISerializable>>>)bobToken,
            bobSigningService,
            carolAddress,
            null
        ).get();

        // Carol imports token
        Token<?> carolToken = tokenFactory.create(bobToken.toJson()).get();
        // Carol gets transaction from Bob
        Transaction<?> carolTransaction = transactionDeserializer.deserialize(
            carolToken.getId(),
            carolToken.getType(),
            TransactionJsonSerializer.serialize(txToCarol)
        ).get();

        // now Carol can create an UnmaskedPredicate knowing token information
        UnmaskedPredicate carolPredicate = UnmaskedPredicate.create(
            carolToken.getId(),
            carolToken.getType(),
            carolSigningService,
            HashAlgorithm.SHA256,
            carolNonce
        ).get();

        // Finish the transaction with the Carol predicate
        assertNull(((TransactionData)carolTransaction.getData()).getDataHash());
        TokenState carolTokenState = TokenState.create(carolPredicate, null).get();
        Token<?> finalizedCarolToken = client.finishTransaction(carolToken, carolTokenState, carolTransaction).get();

        assertEquals(2, finalizedCarolToken.getTransactions().size());
    }

    public static void testOfflineTransferFlow(StateTransitionClient client) throws Exception {
        Token<Transaction<MintTransactionData<ISerializable>>> token;
        byte[] mintDataNonce;
        SigningService firstOwnerSigningService;

        // Mint token
        {
            byte[] coinId1 = new byte[32];
            byte[] coinId2 = new byte[32];
            random.nextBytes(coinId1);
            random.nextBytes(coinId2);
            
            Map<CoinId, BigInteger> coins = new HashMap<>();
            coins.put(new CoinId(coinId1), BigInteger.valueOf(10 + random.nextInt(90)));
            coins.put(new CoinId(coinId2), BigInteger.valueOf(10 + random.nextInt(90)));
            TokenCoinData coinData = TokenCoinData.create(coins);

            MintTokenUtils.MintData data = MintTokenUtils.createMintData(INITIAL_OWNER_SECRET, coinData).get();
            mintDataNonce = data.nonce;
            firstOwnerSigningService = SigningService.createFromSecret(INITIAL_OWNER_SECRET, mintDataNonce).get();
            token = MintTokenUtils.mintToken(client, data).get();

            DirectAddress mintAddress = DirectAddress.create(data.predicate.getReference()).get();
            DirectAddress genesisAddress = DirectAddress.fromJSON(token.getGenesis().getData().getRecipient()).get();
            assertEquals(mintAddress, genesisAddress);
        }

        // Recipient prepares the info for the transfer
        byte[] nonce = new byte[32];
        random.nextBytes(nonce);
        SigningService receiverSigningService = SigningService.createFromSecret(BOB_SECRET, nonce).get();
        MaskedPredicate recipientPredicate = MaskedPredicate.create(
            token.getId(),
            token.getType(),
            receiverSigningService,
            HashAlgorithm.SHA256,
            nonce
        ).get();

        DirectAddress receivingAddress = DirectAddress.create(recipientPredicate.getReference()).get();

        byte[] salt = new byte[32];
        random.nextBytes(salt);
        DataHash dataHash = new DataHasher(HashAlgorithm.SHA256)
            .update("my custom data".getBytes(StandardCharsets.UTF_8))
            .digest().get();
        
        TransactionData transactionData = TransactionData.create(
            token.getState(),
            receivingAddress.toJson(),
            salt,
            dataHash,
            "my message".getBytes(StandardCharsets.UTF_8),
            token.getNametagTokens()
        ).get();

        Commitment commitment = Commitment.create(transactionData, firstOwnerSigningService).get();

        // Test the full JSON serialization cycle
        Map<String, Object> offlineTxJson = new HashMap<>();
        offlineTxJson.put("commitment", CommitmentJsonSerializer.serialize(commitment));
        offlineTxJson.put("token", token.toJson());
        String jsonString = new com.fasterxml.jackson.databind.ObjectMapper().writeValueAsString(offlineTxJson);

        // Simulate transfer and parsing
        Map<String, Object> parsedJson = new com.fasterxml.jackson.databind.ObjectMapper().readValue(
            jsonString, 
            new com.fasterxml.jackson.core.type.TypeReference<Map<String, Object>>() {}
        );

        // Deserialize back to object
        Token<?> importedToken = tokenFactory.create(parsedJson.get("token")).get();
        Commitment importedCommitment = new CommitmentJsonSerializer(predicateFactory).deserialize(
            importedToken.getId(),
            importedToken.getType(),
            parsedJson.get("commitment")
        ).get();

        // Recipient imports token
        var response = client.submitCommitment(importedCommitment).get();
        assertEquals(SubmitCommitmentStatus.SUCCESS, response.getStatus());

        var inclusionProof = InclusionProofUtils.waitInclusionProof(client, importedCommitment).get();
        Transaction<?> confirmedTx = client.createTransaction(importedCommitment, inclusionProof).get();

        // Finish the transaction with the recipient predicate
        TokenState updateTokenState = TokenState.create(recipientPredicate, "my custom data".getBytes(StandardCharsets.UTF_8)).get();
        Token<?> updateToken = client.finishTransaction(importedToken, updateTokenState, confirmedTx).get();

        SigningService signingService = SigningService.createFromSecret(BOB_SECRET, token.getState().getUnlockPredicate().getNonce()).get();
        assertTrue(importedToken.getState().getUnlockPredicate().isOwner(signingService.getPublicKey()).get());
        assertEquals(token.getId(), updateToken.getId());
        assertEquals(token.getType(), updateToken.getType());
        assertEquals(token.getData(), updateToken.getData());
        assertEquals(token.getCoins().toJson(), updateToken.getCoins().toJson());

        // Verify the original minted token has been spent
        SigningService senderSigningService = SigningService.createFromSecret(INITIAL_OWNER_SECRET, mintDataNonce).get();
        InclusionProofVerificationStatus mintedTokenStatus = client.getTokenStatus(token, senderSigningService.getPublicKey()).get();
        assertEquals(InclusionProofVerificationStatus.OK, mintedTokenStatus);

        // Verify the updated token has not been spent
        InclusionProofVerificationStatus transferredTokenStatus = client.getTokenStatus(updateToken, signingService.getPublicKey()).get();
        assertEquals(InclusionProofVerificationStatus.PATH_NOT_INCLUDED, transferredTokenStatus);
    }

    /*
    // TODO: Implement TokenSplitBuilder before enabling these tests
    public static void testSplitFlow(StateTransitionClient client) throws Exception {
        // First, let's mint a token
        byte[] unicityTokenId = new byte[32];
        byte[] alphaTokenId = new byte[32];
        random.nextBytes(unicityTokenId);
        random.nextBytes(alphaTokenId);

        CoinId unicityToken = new CoinId(unicityTokenId);
        CoinId alphaToken = new CoinId(alphaTokenId);

        Map<CoinId, BigInteger> coins = new HashMap<>();
        coins.put(unicityToken, BigInteger.valueOf(10));
        coins.put(alphaToken, BigInteger.valueOf(20));
        TokenCoinData coinData = TokenCoinData.create(coins);

        MintTokenUtils.MintData mintTokenData = MintTokenUtils.createMintData(INITIAL_OWNER_SECRET, coinData).get();
        Token<Transaction<MintTransactionData<ISerializable>>> token = MintTokenUtils.mintToken(client, mintTokenData).get();

        List<TokenCoinData> coinsPerNewTokens = Arrays.asList(
            TokenCoinData.create(Map.of(
                unicityToken, BigInteger.valueOf(10),
                alphaToken, BigInteger.valueOf(5)
            )),
            TokenCoinData.create(Map.of(
                alphaToken, BigInteger.valueOf(15)
            ))
        );

        List<Token<Transaction<MintTransactionData<ISerializable>>>> splitTokens = splitToken(
            token,
            coinsPerNewTokens,
            INITIAL_OWNER_SECRET,
            mintTokenData.nonce,
            "my custom data",
            "my message",
            client
        ).get();

        performCheckForSplitTokens(splitTokens, coinsPerNewTokens);

        // Test serialization
        String newTokenJson = new com.fasterxml.jackson.databind.ObjectMapper().writeValueAsString(
            Map.of("token", splitTokens.get(1).toJson(), "transactions", null)
        );
        Map<String, Object> parsed = new com.fasterxml.jackson.databind.ObjectMapper().readValue(
            newTokenJson,
            new com.fasterxml.jackson.core.type.TypeReference<Map<String, Object>>() {}
        );
        tokenFactory.create(parsed.get("token")).get();
    }
    */

    /*
    public static void testSplitFlowAfterTransfer(StateTransitionClient client) throws Exception {
        byte[] unicityTokenId = new byte[32];
        byte[] alphaTokenId = new byte[32];
        random.nextBytes(unicityTokenId);
        random.nextBytes(alphaTokenId);

        CoinId unicityToken = new CoinId(unicityTokenId);
        CoinId alphaToken = new CoinId(alphaTokenId);

        Map<CoinId, BigInteger> coins = new HashMap<>();
        coins.put(unicityToken, BigInteger.valueOf(100));
        coins.put(alphaToken, BigInteger.valueOf(100));
        TokenCoinData coinData = TokenCoinData.create(coins);

        MintTokenUtils.MintData mintTokenData = MintTokenUtils.createMintData(INITIAL_OWNER_SECRET, coinData).get();
        Token<Transaction<MintTransactionData<ISerializable>>> token = MintTokenUtils.mintToken(client, mintTokenData).get();

        // Perform 1st split
        List<TokenCoinData> coinsPerNewTokens = Arrays.asList(
            TokenCoinData.create(Map.of(
                unicityToken, BigInteger.valueOf(50),
                alphaToken, BigInteger.valueOf(50)
            )),
            TokenCoinData.create(Map.of(
                unicityToken, BigInteger.valueOf(50),
                alphaToken, BigInteger.valueOf(50)
            ))
        );

        List<Token<Transaction<MintTransactionData<ISerializable>>>> splitTokens = splitToken(
            token,
            coinsPerNewTokens,
            INITIAL_OWNER_SECRET,
            mintTokenData.nonce,
            "my custom data",
            "my message",
            client
        ).get();

        performCheckForSplitTokens(splitTokens, coinsPerNewTokens);

        // Transfer first split token to Bob
        byte[] receiverNonce = new byte[32];
        random.nextBytes(receiverNonce);
        SigningService recipientSigningService = SigningService.createFromSecret(BOB_SECRET, receiverNonce).get();

        DataHash reference = MaskedPredicate.calculateReference(
            splitTokens.get(0).getType(),
            recipientSigningService.getAlgorithm(),
            recipientSigningService.getPublicKey(),
            HashAlgorithm.SHA256,
            receiverNonce
        ).get();
        DirectAddress recipientAddress = DirectAddress.create(reference).get();

        // Create transfer transaction
        SigningService senderSigningService = SigningService.createFromSecret(
            INITIAL_OWNER_SECRET, 
            splitTokens.get(0).getState().getUnlockPredicate().getNonce()
        ).get();
        Transaction<TransactionData> sendTokenTx = MintTokenUtils.sendToken(
            client,
            splitTokens.get(0),
            senderSigningService,
            recipientAddress,
            "my custom data"
        ).get();

        // Sender exports token with transfer transaction
        String tokenJson = new com.fasterxml.jackson.databind.ObjectMapper().writeValueAsString(
            Map.of(
                "token", splitTokens.get(0).toJson(),
                "transaction", com.unicity.sdk.serializer.json.TransactionJsonSerializer.serialize(sendTokenTx)
            )
        );

        // Recipient imports token and transaction
        Map<String, Object> parsed = new com.fasterxml.jackson.databind.ObjectMapper().readValue(
            tokenJson,
            new com.fasterxml.jackson.core.type.TypeReference<Map<String, Object>>() {}
        );
        Token<?> receiverImportedToken = tokenFactory.create(parsed.get("token")).get();

        Transaction<?> importedTransaction = transactionDeserializer.deserialize(
            receiverImportedToken.getId(),
            receiverImportedToken.getType(),
            parsed.get("transaction")
        ).get();

        MaskedPredicate maskedPredicate = MaskedPredicate.create(
            receiverImportedToken.getId(),
            receiverImportedToken.getType(),
            recipientSigningService,
            HashAlgorithm.SHA256,
            receiverNonce
        ).get();

        // Finish the transaction with the recipient predicate
        TokenState updateTokenState = TokenState.create(maskedPredicate, "my custom data".getBytes(StandardCharsets.UTF_8)).get();
        Token<?> updateToken = client.finishTransaction(receiverImportedToken, updateTokenState, importedTransaction).get();

        assertTrue(receiverImportedToken.getState().getUnlockPredicate().isOwner(recipientSigningService.getPublicKey()).get());
        assertEquals(splitTokens.get(0).getId(), updateToken.getId());
        assertEquals(splitTokens.get(0).getType(), updateToken.getType());
        assertEquals(splitTokens.get(0).getData(), updateToken.getData());
        assertEquals(splitTokens.get(0).getCoins().toJson(), updateToken.getCoins().toJson());

        // Now let's split that received token into 2 tokens
        List<TokenCoinData> coinsPerNewTokens2 = Arrays.asList(
            TokenCoinData.create(Map.of(
                unicityToken, BigInteger.valueOf(26),
                alphaToken, BigInteger.valueOf(27)
            )),
            TokenCoinData.create(Map.of(
                unicityToken, BigInteger.valueOf(24),
                alphaToken, BigInteger.valueOf(23)
            ))
        );

        List<Token<Transaction<MintTransactionData<ISerializable>>>> splitTokens2 = splitToken(
            (Token<Transaction<MintTransactionData<ISerializable>>>)updateToken,
            coinsPerNewTokens2,
            BOB_SECRET,
            receiverNonce,
            "my custom data",
            "my custom message",
            client
        ).get();

        performCheckForSplitTokens(splitTokens2, coinsPerNewTokens2);
    }
    */

    /*
    private static CompletableFuture<List<Token<Transaction<MintTransactionData<ISerializable>>>>> splitToken(
            Token<Transaction<MintTransactionData<ISerializable>>> token,
            List<TokenCoinData> coinsPerNewTokens,
            byte[] ownerSecret,
            byte[] nonce,
            String customDataString,
            String customMessage,
            StateTransitionClient client) throws Exception {
        
        TokenSplitBuilder builder = new TokenSplitBuilder();
        Map<BigInteger, MaskedPredicate> predicates = new HashMap<>();
        
        for (TokenCoinData coins : coinsPerNewTokens) {
            byte[] tokenIdData = new byte[32];
            random.nextBytes(tokenIdData);
            TokenId tokenId = TokenId.create(tokenIdData);
            
            byte[] tokenTypeData = new byte[32];
            random.nextBytes(tokenTypeData);
            TokenType tokenType = TokenType.create(tokenTypeData);
            
            byte[] newNonce = new byte[32];
            random.nextBytes(newNonce);
            SigningService signingService = SigningService.createFromSecret(ownerSecret, newNonce).get();

            MaskedPredicate predicate = MaskedPredicate.create(tokenId, tokenType, signingService, HashAlgorithm.SHA256, newNonce).get();
            predicates.put(tokenId.toBitString().toBigInteger(), predicate);

            DirectAddress address = DirectAddress.create(predicate.getReference()).get();
            TokenState state = TokenState.create(predicate, customDataString.getBytes(StandardCharsets.UTF_8));
            
            byte[] salt = new byte[32];
            random.nextBytes(salt);
            
            var splitToken = builder.createToken(
                tokenId,
                tokenType,
                new byte[0],
                address.toString(),
                state,
                new DataHasherFactory(HashAlgorithm.SHA256, () -> new DataHasher(HashAlgorithm.SHA256)),
                salt
            );

            for (Map.Entry<CoinId, BigInteger> coin : coins.getCoins().entrySet()) {
                splitToken.addCoin(coin.getKey(), coin.getValue());
            }
        }

        var splitResult = builder.build(new DataHasherFactory(HashAlgorithm.SHA256, () -> new DataHasher(HashAlgorithm.SHA256))).get();

        byte[] burnData = new byte[32];
        random.nextBytes(burnData);
        BurnPredicate burnPredicate = BurnPredicate.create(
            token.getId(),
            token.getType(),
            burnData,
            splitResult.getRootHash()
        ).get();

        DirectAddress burnAddress = DirectAddress.create(burnPredicate.getReference()).get();
        
        byte[] salt = new byte[32];
        random.nextBytes(salt);
        DataHash stateHash = new DataHasher(HashAlgorithm.SHA256)
            .update(customDataString.getBytes(StandardCharsets.UTF_8))
            .digest().get();
        
        TransactionData transactionData = TransactionData.create(
            token.getState(),
            burnAddress.toString(),
            salt,
            stateHash,
            customMessage.getBytes(StandardCharsets.UTF_8),
            Collections.emptyList()
        ).get();
        
        SigningService signingService = SigningService.createFromSecret(ownerSecret, nonce).get();
        // Create authenticator and request ID
        Authenticator authenticator = Authenticator.create(
            signingService,
            transactionData.getHash(),
            transactionData.getSourceState().getHash()
        ).get();
        RequestId requestId = RequestId.create(signingService.getPublicKey(), transactionData.getSourceState().getHash()).get();
        Commitment<TransactionData> commitment = new Commitment<>(requestId, transactionData, authenticator);
        
        var response = client.submitCommitment(commitment).get();
        assertEquals(SubmitCommitmentStatus.SUCCESS, response.getStatus());
        
        var inclusionProof = InclusionProofUtils.waitInclusionProof(client, commitment).get();
        Transaction<?> transaction = client.createTransaction(commitment, inclusionProof).get();

        TokenState burnTokenState = TokenState.create(burnPredicate, customDataString.getBytes(StandardCharsets.UTF_8)).get();
        Token<?> updatedToken = client.finishTransaction(token, burnTokenState, transaction).get();

        List<TokenSplitBuilder.SplitTokenData> splitTokenDataList = splitResult.getSplitTokenDataList(updatedToken).get();
        
        List<CompletableFuture<Token<Transaction<MintTransactionData<ISerializable>>>>> futures = new ArrayList<>();
        
        for (TokenSplitBuilder.SplitTokenData data : splitTokenDataList) {
            CompletableFuture<Token<Transaction<MintTransactionData<ISerializable>>>> future = 
                client.submitMintTransaction(data.getTransactionData())
                    .thenCompose(mintCommitment -> 
                        InclusionProofUtils.waitInclusionProof(client, mintCommitment)
                            .thenCompose(proof -> 
                                client.createTransaction(mintCommitment, proof)
                                    .thenApply(tx -> new Token<>(data.getState(), tx, new ArrayList<>()))
                            )
                    );
            futures.add(future);
        }
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> {
                List<Token<Transaction<MintTransactionData<ISerializable>>>> result = new ArrayList<>();
                for (CompletableFuture<Token<Transaction<MintTransactionData<ISerializable>>>> f : futures) {
                    result.add(f.join());
                }
                return result;
            });
    }
    */
}