package com.unicity.sdk.e2e;

import com.unicity.sdk.ISerializable;
import com.unicity.sdk.StateTransitionClient;
import com.unicity.sdk.address.DirectAddress;
import com.unicity.sdk.api.SubmitCommitmentResponse;
import com.unicity.sdk.api.SubmitCommitmentStatus;
import com.unicity.sdk.predicate.MaskedPredicate;
import com.unicity.sdk.shared.hash.DataHasher;
import com.unicity.sdk.shared.hash.HashAlgorithm;
import com.unicity.sdk.shared.signing.SigningService;
import com.unicity.sdk.token.Token;
import com.unicity.sdk.token.TokenId;
import com.unicity.sdk.token.TokenState;
import com.unicity.sdk.token.TokenType;
import com.unicity.sdk.token.fungible.CoinId;
import com.unicity.sdk.token.fungible.TokenCoinData;
import com.unicity.sdk.transaction.Commitment;
import com.unicity.sdk.transaction.MintTransactionData;
import com.unicity.sdk.transaction.Transaction;
import com.unicity.sdk.transaction.TransactionData;
import com.unicity.sdk.utils.InclusionProofUtils;

import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.concurrent.CompletableFuture;

/**
 * Utility class for minting and sending tokens in e2e tests.
 */
public class MintTokenUtils {
    private static final SecureRandom random = new SecureRandom();

    public static class MintData {
        public final TokenId tokenId;
        public final TokenType tokenType;
        public final TestTokenData tokenData;
        public final TokenCoinData coinData;
        public final byte[] data;
        public final byte[] salt;
        public final byte[] nonce;
        public final MaskedPredicate predicate;

        public MintData(TokenId tokenId, TokenType tokenType, TestTokenData tokenData, 
                       TokenCoinData coinData, byte[] data, byte[] salt, byte[] nonce, 
                       MaskedPredicate predicate) {
            this.tokenId = tokenId;
            this.tokenType = tokenType;
            this.tokenData = tokenData;
            this.coinData = coinData;
            this.data = data;
            this.salt = salt;
            this.nonce = nonce;
            this.predicate = predicate;
        }
    }

    public static CompletableFuture<MintData> createMintData(byte[] secret, TokenCoinData coinData) {
        byte[] tokenIdData = new byte[32];
        random.nextBytes(tokenIdData);
        TokenId tokenId = TokenId.create(tokenIdData);

        byte[] tokenTypeData = new byte[32];
        random.nextBytes(tokenTypeData);
        TokenType tokenType = TokenType.create(tokenTypeData);

        byte[] tokenDataBytes = new byte[32];
        random.nextBytes(tokenDataBytes);
        TestTokenData tokenData = new TestTokenData(tokenDataBytes);

        byte[] data = new byte[32];
        random.nextBytes(data);

        byte[] salt = new byte[32];
        random.nextBytes(salt);

        byte[] nonce = new byte[32];
        random.nextBytes(nonce);

        return SigningService.createFromSecret(secret, nonce)
            .thenCompose(signingService -> 
                MaskedPredicate.create(tokenId, tokenType, signingService, HashAlgorithm.SHA256, nonce)
                    .thenApply(predicate -> new MintData(
                        tokenId, tokenType, tokenData, coinData, data, salt, nonce, predicate
                    ))
            );
    }

    public static CompletableFuture<Token<Transaction<MintTransactionData<?>>>> mintToken(
            StateTransitionClient client, MintData data) {
        
        return DirectAddress.create(data.predicate.getReference())
            .thenCompose(address -> 
                new DataHasher(HashAlgorithm.SHA256).update(data.data).digest()
                    .thenCompose(dataHash -> 
                        MintTransactionData.create(
                            data.tokenId,
                            data.tokenType,
                            data.tokenData.toCBOR(),
                            data.coinData,
                            address.toString(),
                            data.salt,
                            dataHash,
                            null
                        )
                    )
            )
            .thenCompose(client::submitMintTransaction)
            .thenCompose(mintCommitment -> 
                InclusionProofUtils.waitInclusionProof(client, mintCommitment)
                    .thenCompose(inclusionProof -> 
                        client.createTransaction(mintCommitment, inclusionProof)
                    )
                    .thenCompose(mintTransaction -> 
                        TokenState.create(data.predicate, data.data)
                            .thenApply(state -> new Token<>(state, mintTransaction, new java.util.ArrayList<>()))
                    )
            );
    }

    public static CompletableFuture<Transaction<TransactionData>> sendToken(
            StateTransitionClient client,
            Token<Transaction<MintTransactionData<?>>> token,
            SigningService signingService,
            DirectAddress recipient,
            String tokenState) {
        
        CompletableFuture<com.unicity.sdk.shared.hash.DataHash> stateHashFuture;
        if (tokenState != null) {
            stateHashFuture = new DataHasher(HashAlgorithm.SHA256)
                .update(tokenState.getBytes(StandardCharsets.UTF_8))
                .digest();
        } else {
            stateHashFuture = CompletableFuture.completedFuture(null);
        }

        byte[] salt = new byte[32];
        random.nextBytes(salt);
        byte[] message = "my message".getBytes(StandardCharsets.UTF_8);

        return stateHashFuture.thenCompose(stateHash -> 
            TransactionData.create(
                token.getState(),
                recipient.toJson(),
                salt,
                stateHash,
                message,
                token.getNametagTokens()
            ).thenCompose(transactionData -> 
                Commitment.create(transactionData, signingService)
                    .thenCompose(commitment -> 
                        client.submitCommitment(commitment)
                            .thenCompose(response -> {
                                if (response.getStatus() != SubmitCommitmentStatus.SUCCESS) {
                                    return CompletableFuture.failedFuture(
                                        new RuntimeException("Failed to submit transaction commitment: " + response.getStatus())
                                    );
                                }
                                
                                return InclusionProofUtils.waitInclusionProof(client, commitment)
                                    .thenCompose(inclusionProof -> 
                                        client.createTransaction(commitment, inclusionProof)
                                    );
                            })
                    )
            )
        );
    }
}